from typing import Any

# from interfaces.move import Movable
# from interfaces.rotate import Rotable
from interfaces.uobject import UObject
from ioc.container import IoC


def get_obj_property(obj: object) -> iter:
    """ get property objects without __dunder__ """

    props = [x for x in dir(obj) if not x.startswith('_')]
    props_obj = [obj.__getattribute__(obj, prop) for prop in props]
    return zip(props, props_obj)


def make_init(self, obj: UObject):
    """ __init__ method for generated adapter class """

    self._obj = obj


def make_get(propname: str):
    """ fget for interface properties """

    def get_prop(self):
        return IoC.resolve(
            f'{self.__classname__.replace("Adapter", "")}.{str.capitalize(propname)}.Get',
            self._obj
        )

    return get_prop


def make_set(propname: str):
    """ fset for interface properties """

    def set_prop(self, value: Any):
        return IoC.resolve(
            f'{self.__classname__.replace("Adapter", "")}.{str.capitalize(propname)}.Set',
            self._obj,
            value
        )

    return set_prop


class AdapterMetaclass(type):
    """ metaclass to auto generate adapters class """

    def __new__(mcs, clsname, bases, attr):
        props = get_obj_property(attr['interface'])  # get defined properties from interface

        attrs = {
            '__init__': make_init,  # add __init__(self, obj: UObject) to adapter
            '__classname__': clsname,
        }

        for propname, prop in props:
            attrs.update(
                {
                    propname: property(
                        fget=make_get(propname),
                        fset=make_set(propname) if prop.fset else None,  # if read only property fset is None
                    )
                }
            )
        return super(AdapterMetaclass, mcs).__new__(mcs, clsname, bases, attrs)


# Register IoC 'Adapter' for generate adapters by interface
IoC.resolve(
    'IoC.Register',
    'Adapter.Create',
    lambda interface, obj: AdapterMetaclass(
        f'{interface.__name__}Adapter',
        (),
        {'interface': interface}
    )(obj)
).execute()


# manual generate create adapters
# class MovableAdapter(metaclass=AdapterMetaclass):
#     interface = Movable
#
#
# class RotableAdapter(metaclass=AdapterMetaclass):
#     interface = Rotable
# ------------


# class Obj(UObject):
#     def __init__(self, pos, vel):
#         self.position = pos
#         self.velocity = vel
#
#     def get_property(self, name: str) -> Any:
#         return self.__getattribute__(name)
#
#     def set_property(self, name: str, value: Any) -> None:
#         self.__setattr__(name, value)


# if __name__ == '__main__':
#     IoC.resolve('IoC.Register', 'Movable.Position.Get', lambda o: o.get_property('position')).execute()
#     IoC.resolve('IoC.Register', 'Movable.Position.Set', lambda o, value: o.set_property('position', value)).execute()
#     IoC.resolve('IoC.Register', 'Movable.Velocity.Get', lambda o: o.get_property('velocity')).execute()
#     IoC.resolve('IoC.Register', 'Movable.Velocity.Set', lambda o, value: o.set_property('velocity', value)).execute()
#
#     obj = Obj((2, 3), 7)
#     # get autogenerated adapter from IoC
#     ioc_adapter = IoC.resolve("Adapter.Create", Movable, obj)
#
#     obj_movable_adapter = MovableAdapter(obj)
#     print(f'{ioc_adapter.position=!r}\n{ioc_adapter.velocity=!r}')
#     print(f'{obj_movable_adapter.position=!r}\n{obj_movable_adapter.velocity=!r}')
